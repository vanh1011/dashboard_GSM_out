import streamlit as st
import pandas as pd
import polars as pl
import plotly.express as px
from datetime import datetime
import os
from csv_reader import CSVDataReader

# C·∫•u h√¨nh trang
st.set_page_config(
    page_title="PVI-GSM Dashboard System",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS
st.markdown("""
<style>
.block-container {
    padding-top: 1rem;
    padding-bottom: 1rem;
    padding-left: 2rem;
    padding-right: 2rem;
    max-width: 100%;
}

.main-header {
    font-size: 2rem;
    font-weight: 700;
    color: #1f77b4;
    text-align: center;
    margin: 0;
    padding: 0.5rem 0;
    background: linear-gradient(90deg, #1f77b4, #17a2b8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

#MainMenu {visibility: hidden;}
footer {visibility: hidden;}
header {visibility: hidden;}
</style>
""", unsafe_allow_html=True)

class DashboardApp:
    def __init__(self):
        self.reader = CSVDataReader()
        self.init_session_state()
    
    def init_session_state(self):
        if 'current_data' not in st.session_state:
            st.session_state.current_data = None
        if 'taixe_data' not in st.session_state:
            st.session_state.taixe_data = None
        if 'file_info' not in st.session_state:
            st.session_state.file_info = None
        if 'taixe_file_info' not in st.session_state:
            st.session_state.taixe_file_info = None
        if 'selected_date' not in st.session_state:
            st.session_state.selected_date = None
        if 'available_days' not in st.session_state:
            st.session_state.available_days = {}
        if 'load_message' not in st.session_state:
            st.session_state.load_message = ""
        if 'current_tab' not in st.session_state:
            st.session_state.current_tab = "launcher"
    
    def render_header(self):
        st.markdown('<h1 class="main-header">üìä PVI-GSM Dashboard System</h1>', unsafe_allow_html=True)
        
        # Debug info cho navigation
        print(f"DEBUG: render_header - current_tab: {st.session_state.current_tab}")
        
        # Navigation buttons thay v√¨ tabs
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üè† Launcher", key="nav_launcher", use_container_width=True):
                print(f"DEBUG: Launcher nav button clicked")
                st.session_state.current_tab = "launcher"
                st.rerun()
        
        with col2:
            if st.button("üîÑ Reconciliation", key="nav_reconciliation", use_container_width=True):
                print(f"DEBUG: Reconciliation nav button clicked")
                st.session_state.current_tab = "reconciliation"
                st.rerun()
        
        with col3:
            if st.button("üöó T√†i X·∫ø", key="nav_taixe", use_container_width=True):
                print(f"DEBUG: Taixe nav button clicked")
                st.session_state.current_tab = "taixe"
                st.rerun()
        
        # Hi·ªÉn th·ªã current tab
        st.markdown(f"### üìç **ƒêang xem: {st.session_state.current_tab.upper()}**")
    
    def render_sidebar(self):
        with st.sidebar:
            st.markdown("## ‚öôÔ∏è C√†i ƒë·∫∑t")
            
            # Ch·ªçn nƒÉm
            year = st.selectbox(
                "üìÖ NƒÉm:",
                [2025, 2024, 2023],
                index=0,
                key="app_year_selector"
            )
            
            # Ch·ªçn th√°ng
            month = st.selectbox(
                "üìÖ Th√°ng:",
                list(range(1, 13)),
                index=6,
                format_func=lambda x: f"{x:02d}",
                key="app_month_selector"
            )
            
            # Button t·∫£i danh s√°ch ng√†y
            if st.button("üîÑ T·∫£i danh s√°ch ng√†y", key="app_load_days_btn"):
                self.load_available_days(year, month)
                st.rerun()
            
            # Hi·ªÉn th·ªã grid ng√†y n·∫øu c√≥
            if st.session_state.available_days:
                st.markdown(f"### üìÇ C√°c ng√†y c√≥ s·∫µn ({year}/{month:02d})")
                
                # T·∫°o grid buttons
                cols_per_row = 3
                days_list = sorted(st.session_state.available_days.keys())
                
                for i in range(0, len(days_list), cols_per_row):
                    cols = st.sidebar.columns(cols_per_row)
                    
                    for j, day in enumerate(days_list[i:i+cols_per_row]):
                        with cols[j]:
                            day_info = st.session_state.available_days[day]
                            
                            btn_text = f"{day:02d}"
                            if day_info['has_version_2']:
                                btn_text += " ‚≠ê"
                            
                            is_selected = (st.session_state.selected_date == day_info['date_str'])
                            if is_selected:
                                btn_text = f"‚û§ {btn_text}"
                            
                            if st.button(btn_text, key=f"app_day_btn_{day}"):
                                self.load_day_data(year, month, day)
                                st.rerun()
                
                # Legend
                st.sidebar.markdown("""
                **Ch√∫ th√≠ch:**
                - ‚û§ = Ng√†y ƒëang xem
                - ‚≠ê = C√≥ file version 2
                """)
            
            # Message area
            if st.session_state.load_message:
                st.sidebar.info(st.session_state.load_message)
                st.session_state.load_message = ""
    
    def load_available_days(self, year: int, month: int):
        try:
            month_path = os.path.join(self.reader.base_path, str(year), f"{month:02d}")
            
            if not os.path.exists(month_path):
                st.session_state.load_message = f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu th√°ng {month}/{year}"
                return
            
            available_days = {}
            
            for day_name in os.listdir(month_path):
                day_path = os.path.join(month_path, day_name)
                
                if os.path.isdir(day_path) and day_name.isdigit():
                    day = int(day_name)
                    date_str = f"{year}{month:02d}{day:02d}"
                    
                    # Get file info
                    file_info = self.reader.get_file_info(day_path, date_str)
                    
                    if file_info['reconciled_file'] or file_info['taixe_file']:
                        available_days[day] = {
                            'path': day_path,
                            'date_str': date_str,
                            'has_version_2': file_info['has_version_2'],
                            'reconciled_file': file_info['reconciled_file'],
                            'taixe_file': file_info['taixe_file']
                        }
            
            st.session_state.available_days = available_days
            
            if available_days:
                st.session_state.load_message = f"‚úÖ T√¨m th·∫•y {len(available_days)} ng√†y c√≥ d·ªØ li·ªáu"
            else:
                st.session_state.load_message = f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu n√†o trong {month}/{year}"
                
        except Exception as e:
            st.session_state.load_message = f"‚ùå L·ªói khi t·∫£i danh s√°ch ng√†y: {e}"
    
    def load_day_data(self, year: int, month: int, day: int):
        try:
            available_days = st.session_state.available_days
            
            if not available_days or day not in available_days:
                st.session_state.load_message = f"‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ng√†y {day}"
                return
            
            day_info = available_days[day]
            
            # Debug info
            print(f"DEBUG: Loading data for day {day}")
            print(f"DEBUG: Day info: {day_info}")
            
            # Clear previous data
            st.session_state.current_data = None
            st.session_state.taixe_data = None
            st.session_state.file_info = None
            st.session_state.taixe_file_info = None
            st.session_state.selected_date = None
            
            # Load reconciliation data
            if day_info['reconciled_file']:
                print(f"DEBUG: Loading reconciled file: {day_info['reconciled_file']}")
                df = self.reader.read_csv_polars(day_info['reconciled_file'])
                if df is not None and not df.is_empty():
                    print(f"DEBUG: Loaded reconciled data: {df.height} rows")
                    st.session_state.current_data = df
                    st.session_state.file_info = {
                        'date': day_info['date_str'],
                        'reconciled_file': day_info['reconciled_file'],
                        'reconciled_size_mb': os.path.getsize(day_info['reconciled_file']) / (1024 * 1024)
                    }
                else:
                    print(f"DEBUG: Failed to load reconciled data")
            else:
                print(f"DEBUG: No reconciled file found")
            
            # Load taixe data
            if day_info['taixe_file']:
                print(f"DEBUG: Loading taixe file: {day_info['taixe_file']}")
                taixe_df = self.reader.read_csv_polars(day_info['taixe_file'])
                if taixe_df is not None and not taixe_df.is_empty():
                    print(f"DEBUG: Loaded taixe data: {taixe_df.height} rows")
                    st.session_state.taixe_data = taixe_df
                    st.session_state.taixe_file_info = {
                        'date': day_info['date_str'],
                        'taixe_file': day_info['taixe_file'],
                        'taixe_size_mb': os.path.getsize(day_info['taixe_file']) / (1024 * 1024)
                    }
                else:
                    print(f"DEBUG: Failed to load taixe data")
            else:
                print(f"DEBUG: No taixe file found")
            
            st.session_state.selected_date = day_info['date_str']
            st.session_state.load_message = f"‚úÖ ƒê√£ t·∫£i d·ªØ li·ªáu ng√†y {day:02d}/{month:02d}/{year}"
            
            print(f"DEBUG: Final session state:")
            print(f"  - current_data: {st.session_state.current_data is not None}")
            print(f"  - taixe_data: {st.session_state.taixe_data is not None}")
            print(f"  - selected_date: {st.session_state.selected_date}")
            
        except Exception as e:
            print(f"DEBUG: Error loading data: {e}")
            st.session_state.load_message = f"‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu: {e}"
    
    def render_launcher(self):
        st.markdown("### üéØ Ch·ªçn dashboard ƒë·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu PVI-GSM")
        
        # H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
        st.info("""
        **üìã H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:**
        1. **Ch·ªçn nƒÉm/th√°ng** t·ª´ sidebar b√™n tr√°i
        2. **Click "üîÑ T·∫£i danh s√°ch ng√†y"** ƒë·ªÉ load danh s√°ch ng√†y c√≥ s·∫µn
        3. **Ch·ªçn ng√†y** t·ª´ grid hi·ªÉn th·ªã
        4. **Ch·ªçn tab** Reconciliation ho·∫∑c T√†i X·∫ø ƒë·ªÉ xem data
        """)
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            <div style="background: white; padding: 2rem; border-radius: 12px; border-left: 6px solid #28a745;">
                <h2>üîÑ Reconciliation Dashboard</h2>
                <p><strong>Ph√¢n t√≠ch ƒë·ªëi so√°t giao d·ªãch ch√≠nh</strong></p>
            </div>
            """, unsafe_allow_html=True)
            
            if st.button("üöÄ M·ªü Reconciliation Dashboard", key="btn_reconciled", use_container_width=True):
                print(f"DEBUG: Reconciliation button clicked")
                st.session_state.current_tab = "reconciliation"
                print(f"DEBUG: Set current_tab to: {st.session_state.current_tab}")
                st.rerun()
        
        with col2:
            st.markdown("""
            <div style="background: white; padding: 2rem; border-radius: 12px; border-left: 6px solid #e74c3c;">
                <h2>üöó T√†i X·∫ø Dashboard</h2>
                <p><strong>Ph√¢n t√≠ch ƒë∆°n tai n·∫°n t√†i x·∫ø</strong></p>
            </div>
            """, unsafe_allow_html=True)
            
            if st.button("üöÄ M·ªü T√†i X·∫ø Dashboard", key="btn_taixe", use_container_width=True):
                print(f"DEBUG: Taixe button clicked")
                st.session_state.current_tab = "taixe"
                print(f"DEBUG: Set current_tab to: {st.session_state.current_tab}")
                st.rerun()
        
        # Debug info
        st.markdown("### üêõ Debug Info")
        col_debug1, col_debug2, col_debug3 = st.columns(3)
        
        with col_debug1:
            st.write("**Session State:**")
            st.write(f"- Current Tab: {st.session_state.current_tab}")
            st.write(f"- Selected Date: {st.session_state.selected_date}")
            st.write(f"- Available Days: {len(st.session_state.available_days)}")
        
        with col_debug2:
            st.write("**Data Status:**")
            st.write(f"- Reconciliation Data: {'‚úÖ' if st.session_state.current_data is not None else '‚ùå'}")
            st.write(f"- Taixe Data: {'‚úÖ' if st.session_state.taixe_data is not None else '‚ùå'}")
            st.write(f"- File Info: {'‚úÖ' if st.session_state.file_info is not None else '‚ùå'}")
        
        with col_debug3:
            st.write("**Path Info:**")
            st.write(f"- Base Path: {self.reader.base_path}")
            st.write(f"- Path Exists: {'‚úÖ' if os.path.exists(self.reader.base_path) else '‚ùå'}")
            if os.path.exists(self.reader.base_path):
                try:
                    year_folders = os.listdir(self.reader.base_path)
                    st.write(f"- Years: {year_folders}")
                except:
                    st.write("- Years: Error reading")
        
        # Th√¥ng tin chung
        st.markdown("---")
        st.markdown("### üìã Th√¥ng tin chung")
        
        col_info1, col_info2, col_info3 = st.columns(3)
        
        with col_info1:
            st.markdown("""
            **üìÅ C·∫•u tr√∫c th∆∞ m·ª•c:**
            ```
            F:/powerbi/gsm_data/out/
            ‚îú‚îÄ‚îÄ 2025/07/01/
            ‚îÇ   ‚îú‚îÄ‚îÄ pvi_transaction_reconciled_20250701.csv
            ‚îÇ   ‚îú‚îÄ‚îÄ pvi_transaction_reconciled_20250701_2.csv
            ‚îÇ   ‚îî‚îÄ‚îÄ pvi_transaction_reconciled_taixe_20250701.csv
            ```
            """)
        
        with col_info2:
            st.markdown("""
            **üìä Lo·∫°i file:**
            
            **üîÑ Reconciliation:**
            - `pvi_transaction_reconciled_YYYYMMDD.csv`
            - `pvi_transaction_reconciled_YYYYMMDD_2.csv` (∆∞u ti√™n)
            
            **üöó T√†i x·∫ø:**
            - `pvi_transaction_reconciled_taixe_YYYYMMDD.csv`
            """)
        
        with col_info3:
            st.markdown("""
            **‚ö° C√¥ng ngh·ªá:**
            
            - **üêç Python**: Streamlit, Polars, Pandas
            - **üìä Visualization**: Plotly Express
            - **üöÄ Performance**: Polars cho file l·ªõn
            - **üíæ Data**: CSV files (100MB+)
            """)
    
    def render_reconciliation_dashboard(self):
        print(f"DEBUG: render_reconciliation_dashboard called")
        print(f"DEBUG: current_data is None: {st.session_state.current_data is None}")
        print(f"DEBUG: selected_date: {st.session_state.selected_date}")
        
        if st.session_state.current_data is None:
            st.warning("‚ö†Ô∏è **Ch∆∞a c√≥ d·ªØ li·ªáu!** Vui l√≤ng:")
            st.markdown("""
            1. **Ch·ªçn nƒÉm/th√°ng** t·ª´ sidebar b√™n tr√°i
            2. **Click "üîÑ T·∫£i danh s√°ch ng√†y"** 
            3. **Ch·ªçn ng√†y** t·ª´ grid hi·ªÉn th·ªã
            4. **Quay l·∫°i tab n√†y** ƒë·ªÉ xem data
            """)
            
            # Debug info
            st.markdown("### üêõ Debug Info")
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Current Data:** {st.session_state.current_data}")
                st.write(f"**Selected Date:** {st.session_state.selected_date}")
                st.write(f"**Available Days:** {len(st.session_state.available_days)}")
            with col2:
                st.write(f"**File Info:** {st.session_state.file_info}")
                st.write(f"**Base Path:** {self.reader.base_path}")
                st.write(f"**Path Exists:** {os.path.exists(self.reader.base_path)}")
            return
        
        df = st.session_state.current_data
        print(f"DEBUG: Data loaded successfully: {df.height} rows, {df.width} columns")
        
        # File info
        if st.session_state.file_info:
            info = st.session_state.file_info
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("üìÖ Ng√†y", info['date'])
            with col2:
                st.metric("üìÑ File", os.path.basename(info['reconciled_file']))
            with col3:
                st.metric("üìä Size", f"{info['reconciled_size_mb']:.1f} MB")
            with col4:
                st.metric("üìù Records", f"{df.height:,}")
        
        # Summary stats
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üìù Records", f"{df.height:,}")
        with col2:
            if 'ORDER_ID' in df.columns:
                unique_orders = df.select(pl.col('ORDER_ID').n_unique()).item()
                st.metric("üÜî Orders", f"{unique_orders:,}")
            else:
                st.metric("üÜî Orders", "N/A")
        with col3:
            if 'MERCHANT' in df.columns:
                unique_merchants = df.select(pl.col('MERCHANT').n_unique()).item()
                st.metric("üè™ Merchants", f"{unique_merchants:,}")
            else:
                st.metric("üè™ Merchants", "N/A")
        with col4:
            if 'AMOUNT' in df.columns:
                total_amount = df.select(pl.col('AMOUNT').sum()).item()
                st.metric("üí∞ Total", f"{total_amount:,.0f}")
            else:
                st.metric("üí∞ Total", "N/A")
        
        # Analysis tabs
        tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs(["üîÑ ƒê·ªëi so√°t", "üõ°Ô∏è B·∫£o hi·ªÉm", "üè¢ Business", "üöó Service Type", "üîç T√¨m ki·∫øm", "üëÅÔ∏è D·ªØ li·ªáu"])
        
        with tab1:
            self.render_reconcile_analysis(df)
        
        with tab2:
            self.render_insurance_analysis(df)
        
        with tab3:
            self.render_business_analysis(df)
        
        with tab4:
            self.render_service_type_analysis(df)
        
        with tab5:
            self.render_search_orders(df)
        
        with tab6:
            self.render_data_viewer(df)
    
    def render_taixe_dashboard(self):
        if st.session_state.taixe_data is None:
            st.warning("‚ö†Ô∏è **Ch∆∞a c√≥ d·ªØ li·ªáu t√†i x·∫ø!** Vui l√≤ng:")
            st.markdown("""
            1. **Ch·ªçn nƒÉm/th√°ng** t·ª´ sidebar b√™n tr√°i
            2. **Click "üîÑ T·∫£i danh s√°ch ng√†y"** 
            3. **Ch·ªçn ng√†y** t·ª´ grid hi·ªÉn th·ªã
            4. **Quay l·∫°i tab n√†y** ƒë·ªÉ xem data
            """)
            
            # Debug info
            st.markdown("### üêõ Debug Info")
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Taixe Data:** {st.session_state.taixe_data}")
                st.write(f"**Selected Date:** {st.session_state.selected_date}")
                st.write(f"**Available Days:** {len(st.session_state.available_days)}")
            with col2:
                st.write(f"**Taixe File Info:** {st.session_state.taixe_file_info}")
                st.write(f"**Base Path:** {self.reader.base_path}")
                st.write(f"**Path Exists:** {os.path.exists(self.reader.base_path)}")
            return
        
        df = st.session_state.taixe_data
        
        # File info
        if st.session_state.taixe_file_info:
            info = st.session_state.taixe_file_info
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("üìÖ Ng√†y", info['date'])
            with col2:
                st.metric("üìÑ File", os.path.basename(info['taixe_file']))
            with col3:
                st.metric("üìä Size", f"{info['taixe_size_mb']:.1f} MB")
            with col4:
                st.metric("üìù Records", f"{df.height:,}")
        
        # Summary stats
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üìù Records", f"{df.height:,}")
        with col2:
            st.metric("üìã Columns", f"{df.width}")
        with col3:
            if 'AMOUNT' in df.columns:
                total_amount = df.select(pl.col('AMOUNT').sum()).item()
                st.metric("üí∞ Total", f"{total_amount:,.0f}")
            else:
                st.metric("üí∞ Total", "N/A")
        with col4:
            if 'ORDER_ID' in df.columns:
                unique_orders = df.select(pl.col('ORDER_ID').n_unique()).item()
                st.metric("üÜî Orders", f"{unique_orders:,}")
            else:
                st.metric("üÜî Orders", "N/A")
        
        # Analysis tabs
        tab1, tab2, tab3 = st.tabs(["üöó Ph√¢n t√≠ch", "üîç T√¨m ki·∫øm", "üëÅÔ∏è D·ªØ li·ªáu"])
        
        with tab1:
            self.render_taixe_analysis(df)
        
        with tab2:
            self.render_taixe_search(df)
        
        with tab3:
            self.render_taixe_data_viewer(df)
    
    def render_reconcile_analysis(self, df):
        # T√¨m c·ªôt RECONCILE_STATUS v·ªõi c√°c t√™n c√≥ th·ªÉ c√≥
        reconcile_col = None
        possible_reconcile_cols = ['RECONCILE_STATUS', 'Reconcile Status', 'RECONCILE STATUS', 'RECONCILE', 'GSM_ORDER_RECONCILE', 'GSM_ORDE_RECONCILE', 'RECONCILE_STAT']
        
        for col in possible_reconcile_cols:
            if col in df.columns:
                reconcile_col = col
                break
        
        if reconcile_col:
            st.success(f"‚úÖ T√¨m th·∫•y c·ªôt: **{reconcile_col}**")
            
            reconcile_stats = df.group_by(reconcile_col).agg(
                pl.count().alias('count')
            ).sort('count', descending=True)
            
            col1, col2 = st.columns([1, 1])
            
            with col1:
                st.markdown("#### üìä S·ªë li·ªáu th·ªëng k√™")
                
                # Hi·ªÉn th·ªã c√°c status v·ªõi buttons ƒë·ªÉ drill down
                for row in reconcile_stats.iter_rows(named=True):
                    status = row[reconcile_col]
                    count = row['count']
                    percentage = (count / df.height) * 100
                    
                    # M√†u s·∫Øc theo tr·∫°ng th√°i
                    if status == 'match':
                        icon = "‚úÖ"
                        button_type = "secondary"
                    elif 'not_found_in_m' in status:
                        icon = "‚ùå"
                        button_type = "primary"
                    elif 'not_found_in_external' in status:
                        icon = "‚ö†Ô∏è"
                        button_type = "primary"
                    else:
                        icon = "üìä"
                        button_type = "primary"
                    
                    # Card v·ªõi button ƒë·ªÉ drill down
                    with st.container():
                        col_btn, col_info = st.columns([3, 1])
                        
                        with col_btn:
                            st.markdown(f"""
                            <div class="metric-card">
                                <strong>{icon} {status}</strong><br>
                                {count:,} records ({percentage:.1f}%)
                            </div>
                            """, unsafe_allow_html=True)
                        
                        with col_info:
                            # Ch·ªâ hi·ªÉn th·ªã button drill-down cho non-match status c√≥ √≠t records
                            if status != 'match' and count < 10000:  # Ch·ªâ cho ph√©p drill-down n·∫øu < 10k records
                                if st.button(f"üîç Chi ti·∫øt", key=f"drill_{status}", type=button_type, help=f"Xem chi ti·∫øt {count} records"):
                                    # Store drill-down data in session state
                                    filtered_df = df.filter(pl.col(reconcile_col) == status)
                                    st.session_state.drill_down_data = filtered_df
                                    st.session_state.drill_down_status = status
                                    st.session_state.drill_down_count = count
                                    st.rerun()
                    
                    st.markdown("<br>", unsafe_allow_html=True)
            
            with col2:
                # Bi·ªÉu ƒë·ªì pie chart
                fig = px.pie(
                    reconcile_stats.to_pandas(),
                    values='count',
                    names=reconcile_col,
                    title=f"Ph√¢n b·ªë {reconcile_col}",
                    color_discrete_map={
                        'match': '#28a745',
                        'not_found_in_m': '#dc3545',
                        'not_found_in_external': '#ffc107'
                    }
                )
                fig.update_traces(textposition='inside', textinfo='percent+label')
                fig.update_layout(height=400)
                st.plotly_chart(fig, use_container_width=True)
        
        # Hi·ªÉn th·ªã drill-down data n·∫øu c√≥
        if st.session_state.get('drill_down_data') is not None:
            self.render_drill_down_analysis()
        
        # Th√™m ph√¢n t√≠ch amount theo service type
        self.render_amount_analysis_by_service_type(df)
        
    def render_insurance_analysis(self, df):
        if 'INSURANCE_STATUS' in df.columns:
            insurance_stats = df.group_by('INSURANCE_STATUS').agg(
                pl.count().alias('count')
            ).sort('count', descending=True)

            fig = px.bar(
                insurance_stats.to_pandas(),
                x='INSURANCE_STATUS',
                y='count',
                title="Ph√¢n b·ªë INSURANCE_STATUS"
            )
            st.plotly_chart(fig, use_container_width=True)
    
    def render_search_orders(self, df):
        order_ids_input = st.text_area(
            "Nh·∫≠p Order IDs (m·ªói d√≤ng m·ªôt ID):",
            height=100
        )
        
        if st.button("üîç T√¨m ki·∫øm"):
            if order_ids_input and 'ORDER_ID' in df.columns:
                order_ids = [id.strip() for id in order_ids_input.split('\n') if id.strip()]
                results = df.filter(pl.col('ORDER_ID').is_in(order_ids))
                
                if not results.is_empty():
                    st.success(f"‚úÖ T√¨m th·∫•y {results.height} b·∫£n ghi")
                    st.dataframe(results.to_pandas(), use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Order ID n√†o")
    
    def render_data_viewer(self, df):
        show_rows = st.number_input("S·ªë d√≤ng hi·ªÉn th·ªã:", min_value=10, max_value=1000, value=100)
        st.dataframe(df.head(show_rows).to_pandas(), use_container_width=True)
    
    def render_taixe_analysis(self, df):
        # Debug: Hi·ªÉn th·ªã t√™n c·ªôt th·ª±c t·∫ø
        st.markdown("### üîç Debug: T√™n c·ªôt th·ª±c t·∫ø")
        st.write(f"**T·ªïng s·ªë c·ªôt:** {df.width}")
        st.write(f"**T√™n c√°c c·ªôt:** {list(df.columns)}")
        
        # Ph√¢n t√≠ch Bike vs Car d·ª±a tr√™n GSM_AMOUNT
        st.markdown("### üöó Ph√¢n t√≠ch Bike vs Car (d·ª±a tr√™n GSM_AMOUNT)")
        
        # T√¨m c·ªôt GSM_AMOUNT v·ªõi c√°c t√™n c√≥ th·ªÉ c√≥
        gsm_amount_col = None
        possible_gsm_cols = ['GSM Amount', 'GSM_AMOUNT', 'GSM_AMO', 'GSM_AMOUNT_MERCHANT', 'GSM_AMO_MERCHANT', 'GSM_AMOUNT_MERCH', 'GSM_AMO_MERCH']
        
        for col in possible_gsm_cols:
            if col in df.columns:
                gsm_amount_col = col
                break
        
        if gsm_amount_col:
            st.success(f"‚úÖ T√¨m th·∫•y c·ªôt: **{gsm_amount_col}**")
            
            # Ph√¢n t√≠ch theo GSM_AMOUNT: 100 = Bike, 200 = Car
            bike_df = df.filter(pl.col(gsm_amount_col) == 100)
            car_df = df.filter(pl.col(gsm_amount_col) == 200)
            other_df = df.filter(~pl.col(gsm_amount_col).is_in([100, 200]))
            
            bike_count = bike_df.height
            car_count = car_df.height
            other_count = other_df.height
            
            col1, col2 = st.columns([1, 1])
            
            with col1:
                st.markdown("#### üìä Th·ªëng k√™ Bike vs Car")
                
                total = df.height
                bike_percentage = (bike_count / total * 100) if total > 0 else 0
                car_percentage = (car_count / total * 100) if total > 0 else 0
                other_percentage = (other_count / total * 100) if total > 0 else 0
                
                st.markdown(f"**üõµ Bike ({gsm_amount_col} = 100)**: {bike_count:,} ({bike_percentage:.1f}%)")
                st.markdown(f"**üöó Car ({gsm_amount_col} = 200)**: {car_count:,} ({car_percentage:.1f}%)")
                if other_count > 0:
                    st.markdown(f"**üöô Kh√°c**: {other_count:,} ({other_percentage:.1f}%)")
                
                # Summary metrics
                st.markdown("---")
                col_bike, col_car = st.columns(2)
                with col_bike:
                    st.metric("üõµ Bike Orders", f"{bike_count:,}")
                with col_car:
                    st.metric("üöó Car Orders", f"{car_count:,}")
            
            with col2:
                # Pie chart cho Bike vs Car
                vehicle_data = {
                    'Lo·∫°i xe': ['Bike', 'Car', 'Kh√°c'],
                    'S·ªë l∆∞·ª£ng': [bike_count, car_count, other_count]
                }
                vehicle_df = pd.DataFrame(vehicle_data)
                
                fig_vehicle = px.pie(
                    vehicle_df,
                    values='S·ªë l∆∞·ª£ng',
                    names='Lo·∫°i xe',
                    title="Ph√¢n b·ªë Bike vs Car",
                    color_discrete_sequence=['#FF9999', '#66B2FF', '#99FF99']
                )
                fig_vehicle.update_traces(textposition='inside', textinfo='percent+label')
                fig_vehicle.update_layout(height=400)
                st.plotly_chart(fig_vehicle, use_container_width=True)
        else:
            st.warning(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c·ªôt GSM_AMOUNT. ƒê√£ t√¨m ki·∫øm: {possible_gsm_cols}")
            st.info("üí° D·ª±a v√†o h√¨nh ·∫£nh, c√≥ th·ªÉ t√™n c·ªôt l√† 'GSM Amo Merchant' ho·∫∑c t∆∞∆°ng t·ª±")
        
        # Ph√¢n t√≠ch RECONCILE_STATUS
        st.markdown("### üîÑ Ph√¢n t√≠ch RECONCILE_STATUS")
        
        # T√¨m c·ªôt RECONCILE_STATUS v·ªõi c√°c t√™n c√≥ th·ªÉ c√≥
        reconcile_col = None
        possible_reconcile_cols = ['Reconcile Status', 'RECONCILE STATUS', 'RECONCILE_STATUS', 'RECONCILE', 'GSM_ORDER_RECONCILE', 'GSM_ORDE_RECONCILE', 'RECONCILE_STAT']
        
        for col in possible_reconcile_cols:
            if col in df.columns:
                reconcile_col = col
                break
        
        if reconcile_col:
            st.success(f"‚úÖ T√¨m th·∫•y c·ªôt: **{reconcile_col}**")
            
            reconcile_stats = df.group_by(reconcile_col).agg(
                pl.count().alias('count')
            ).sort('count', descending=True)

            col1, col2 = st.columns([1, 1])
            
            with col1:
                st.markdown("#### üìä Th·ªëng k√™ RECONCILE_STATUS")
                
                # Hi·ªÉn th·ªã c√°c status v·ªõi buttons ƒë·ªÉ drill down
                for row in reconcile_stats.iter_rows(named=True):
                    status = row[reconcile_col]
                    count = row['count']
                    percentage = (count / df.height) * 100
                    
                    # M√†u s·∫Øc theo tr·∫°ng th√°i
                    if status == 'match':
                        icon = "‚úÖ"
                        button_type = "secondary"
                    elif 'not_found_in_m' in status:
                        icon = "‚ùå"
                        button_type = "primary"
                    elif 'not_found_in_external' in status:
                        icon = "‚ö†Ô∏è"
                        button_type = "primary"
                    else:
                        icon = "üìä"
                        button_type = "primary"
                    
                    # Card v·ªõi button ƒë·ªÉ drill down
                    with st.container():
                        col_btn, col_info = st.columns([3, 1])
                        
                        with col_btn:
                            st.markdown(f"""
                            <div class="metric-card">
                                <strong>{icon} {status}</strong><br>
                                {count:,} records ({percentage:.1f}%)
                            </div>
                            """, unsafe_allow_html=True)
                        
                        with col_info:
                            # Ch·ªâ hi·ªÉn th·ªã button drill-down cho non-match status c√≥ √≠t records
                            if status != 'match' and count < 10000:  # Ch·ªâ cho ph√©p drill-down n·∫øu < 10k records
                                if st.button(f"üîç Chi ti·∫øt", key=f"taixe_drill_{status}", type=button_type, help=f"Xem chi ti·∫øt {count} records"):
                                    # Store drill-down data in session state
                                    filtered_df = df.filter(pl.col(reconcile_col) == status)
                                    st.session_state.drill_down_data = filtered_df
                                    st.session_state.drill_down_status = status
                                    st.session_state.drill_down_count = count
                                    st.rerun()
                    
                    st.markdown("<br>", unsafe_allow_html=True)
            
            with col2:
                # Pie chart cho RECONCILE_STATUS
                fig = px.pie(
                    reconcile_stats.to_pandas(),
                    values='count',
                    names=reconcile_col,
                    title=f"Ph√¢n b·ªë {reconcile_col} - T√†i x·∫ø",
                    color_discrete_map={
                        'match': '#28a745',
                        'not_found_in_m': '#dc3545',
                        'not_found_in_external': '#ffc107'
                    }
                )
                fig.update_traces(textposition='inside', textinfo='percent+label')
                fig.update_layout(height=400)
                st.plotly_chart(fig, use_container_width=True)
        
        # Hi·ªÉn th·ªã drill-down data n·∫øu c√≥
        if st.session_state.get('drill_down_data') is not None:
            self.render_drill_down_analysis()
        
        # Ph√¢n t√≠ch MERCHANT_STATUS
        st.markdown("### üè™ Ph√¢n t√≠ch MERCHANT_STATUS")
        
        # T√¨m c·ªôt MERCHANT_STATUS v·ªõi c√°c t√™n c√≥ th·ªÉ c√≥
        merchant_status_col = None
        possible_merchant_cols = ['Merchant Status', 'MERCHANT_STATUS', 'GSM_STATUS_MERCHANT', 'GSM_STATU_MERCHANT', 'MERCHANT_STAT', 'MERCH_STATUS']
        
        for col in possible_merchant_cols:
            if col in df.columns:
                merchant_status_col = col
                break
        
        if merchant_status_col:
            st.success(f"‚úÖ T√¨m th·∫•y c·ªôt: **{merchant_status_col}**")
            
            merchant_status_stats = df.group_by(merchant_status_col).agg(
                pl.count().alias('count')
            ).sort('count', descending=True)
            
            st.markdown("#### üìä S·ªë li·ªáu th·ªëng k√™")
            
            # Hi·ªÉn th·ªã c√°c status v·ªõi buttons ƒë·ªÉ drill down
            for row in merchant_status_stats.iter_rows(named=True):
                status = row[merchant_status_col]
                count = row['count']
                percentage = (count / df.height) * 100
                
                # X√°c ƒë·ªãnh m√†u v√† button type d·ª±a tr√™n status
                if 'fail' in str(status).lower() or 'error' in str(status).lower():
                    color = "üî¥"
                    button_type = "secondary"
                elif 'success' in str(status).lower() or 'match' in str(status).lower():
                    color = "üü¢"
                    button_type = "primary"
                else:
                    color = "üü°"
                    button_type = "secondary"
                
                col1, col2, col3 = st.columns([3, 1, 1])
                
                with col1:
                    st.markdown(f"{color} **{status}**: {count:,} records ({percentage:.1f}%)")
                
                with col2:
                    st.metric("S·ªë l∆∞·ª£ng", f"{count:,}")
                
                with col3:
                    # Hi·ªÉn th·ªã button drill-down cho t·∫•t c·∫£ status, ƒë·∫∑c bi·ªát l√† failed
                    if count < 10000:  # Ch·ªâ cho ph√©p drill-down n·∫øu < 10k records
                        if st.button(f"üîç Chi ti·∫øt", key=f"merchant_drill_{status}", type=button_type, help=f"Xem chi ti·∫øt {count} records"):
                            # Store drill-down data in session state
                            filtered_df = df.filter(pl.col(merchant_status_col) == status)
                            st.session_state.drill_down_data = filtered_df
                            st.session_state.drill_down_status = f"Merchant Status: {status}"
                            st.session_state.show_drill_down = True
                            st.rerun()
                
                st.divider()
            
            # Hi·ªÉn th·ªã ri√™ng c√°c ƒë∆°n failed
            st.markdown("#### üî¥ C√°c ƒë∆°n Failed/Error")
            
            failed_statuses = []
            for row in merchant_status_stats.iter_rows(named=True):
                status = row[merchant_status_col]
                if 'fail' in str(status).lower() or 'error' in str(status).lower():
                    failed_statuses.append(row)
            
            if failed_statuses:
                for row in failed_statuses:
                    status = row[merchant_status_col]
                    count = row['count']
                    percentage = (count / df.height) * 100
                    
                    col1, col2, col3, col4 = st.columns([2, 1, 1, 1])
                    
                    with col1:
                        st.markdown(f"üî¥ **{status}**")
                    
                    with col2:
                        st.metric("S·ªë ƒë∆°n", f"{count:,}")
                    
                    with col3:
                        st.metric("T·ª∑ l·ªá", f"{percentage:.1f}%")
                    
                    with col4:
                        if st.button(f"üìã Xem chi ti·∫øt", key=f"failed_detail_{status}", type="secondary"):
                            # Store drill-down data in session state
                            filtered_df = df.filter(pl.col(merchant_status_col) == status)
                            st.session_state.drill_down_data = filtered_df
                            st.session_state.drill_down_status = f"Failed Merchant Status: {status}"
                            st.session_state.show_drill_down = True
                            st.rerun()
                    
                    st.divider()
                
                # T·ªïng k·∫øt failed
                total_failed = sum(row['count'] for row in failed_statuses)
                total_failed_percentage = (total_failed / df.height) * 100
                
                st.markdown("#### üìä T·ªïng k·∫øt Failed")
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("üî¥ T·ªïng ƒë∆°n Failed", f"{total_failed:,}")
                with col2:
                    st.metric("üìä T·ª∑ l·ªá Failed", f"{total_failed_percentage:.1f}%")
                with col3:
                    st.metric("‚úÖ ƒê∆°n th√†nh c√¥ng", f"{df.height - total_failed:,}")
                
            else:
                st.success("‚úÖ Kh√¥ng c√≥ ƒë∆°n n√†o b·ªã failed/error!")
            
            # Pie chart
            fig_merchant = px.pie(
                merchant_status_stats.to_pandas(),
                values='count',
                names=merchant_status_col,
                title=f"Ph√¢n b·ªë {merchant_status_col} - T√†i x·∫ø",
                color_discrete_map={
                    'success': '#28a745',
                    'failed': '#dc3545',
                    'error': '#dc3545',
                    'match': '#28a745',
                    'not_found': '#ffc107'
                }
            )
            fig_merchant.update_traces(textposition='inside', textinfo='percent+label')
            fig_merchant.update_layout(height=400)
            st.plotly_chart(fig_merchant, use_container_width=True)
        else:
            st.info("‚ÑπÔ∏è Kh√¥ng c√≥ c·ªôt MERCHANT_STATUS ƒë·ªÉ ph√¢n t√≠ch")
        
        # Ph√¢n t√≠ch Amount theo lo·∫°i xe
        st.markdown("### üí∞ Ph√¢n t√≠ch Amount theo lo·∫°i xe (Bike vs Car)")
        
        if 'GSM Amount' in df.columns and 'Merchant Amount' in df.columns:
            # Ph√¢n t√≠ch GSM Amount theo lo·∫°i xe
            gsm_bike_df = df.filter(pl.col('GSM Amount') == 100)
            gsm_car_df = df.filter(pl.col('GSM Amount') == 200)
            
            # Ph√¢n t√≠ch Merchant Amount theo lo·∫°i xe
            merchant_bike_df = df.filter(pl.col('Merchant Amount') == 100)
            merchant_car_df = df.filter(pl.col('Merchant Amount') == 200)
            
            # T√≠nh t·ªïng ti·ªÅn
            gsm_bike_total = gsm_bike_df.select(pl.col('GSM Amount').sum()).item() if not gsm_bike_df.is_empty() else 0
            gsm_car_total = gsm_car_df.select(pl.col('GSM Amount').sum()).item() if not gsm_car_df.is_empty() else 0
            merchant_bike_total = merchant_bike_df.select(pl.col('Merchant Amount').sum()).item() if not merchant_bike_df.is_empty() else 0
            merchant_car_total = merchant_car_df.select(pl.col('Merchant Amount').sum()).item() if not merchant_car_df.is_empty() else 0
            
            # S·ªë l∆∞·ª£ng ƒë∆°n h√†ng
            gsm_bike_count = gsm_bike_df.height
            gsm_car_count = gsm_car_df.height
            merchant_bike_count = merchant_bike_df.height
            merchant_car_count = merchant_car_df.height
            
            col1, col2 = st.columns([1, 1])
            
            with col1:
                st.markdown("#### üìä GSM Amount theo lo·∫°i xe")
                
                # T·∫°o d·ªØ li·ªáu cho chart
                gsm_data = {
                    'Lo·∫°i xe': ['Bike (100)', 'Car (200)'],
                    'T·ªïng ti·ªÅn': [gsm_bike_total, gsm_car_total],
                    'S·ªë ƒë∆°n': [gsm_bike_count, gsm_car_count]
                }
                gsm_df = pd.DataFrame(gsm_data)
                
                # Bar chart cho GSM Amount
                fig_gsm = px.bar(
                    gsm_df,
                    x='Lo·∫°i xe',
                    y='T·ªïng ti·ªÅn',
                    title="GSM Amount theo lo·∫°i xe",
                    labels={'T·ªïng ti·ªÅn': 'T·ªïng GSM Amount (VND)', 'Lo·∫°i xe': 'Lo·∫°i xe'},
                    color='T·ªïng ti·ªÅn',
                    color_continuous_scale='viridis'
                )
                fig_gsm.update_layout(height=400)
                st.plotly_chart(fig_gsm, use_container_width=True)
                
                # Metrics
                col_gsm1, col_gsm2 = st.columns(2)
                with col_gsm1:
                    st.metric("üõµ Bike GSM", f"{gsm_bike_total:,.0f} VND", f"{gsm_bike_count:,} ƒë∆°n")
                with col_gsm2:
                    st.metric("üöó Car GSM", f"{gsm_car_total:,.0f} VND", f"{gsm_car_count:,} ƒë∆°n")
            
            with col2:
                st.markdown("#### üìä Merchant Amount theo lo·∫°i xe")
                
                # T·∫°o d·ªØ li·ªáu cho chart
                merchant_data = {
                    'Lo·∫°i xe': ['Bike (100)', 'Car (200)'],
                    'T·ªïng ti·ªÅn': [merchant_bike_total, merchant_car_total],
                    'S·ªë ƒë∆°n': [merchant_bike_count, merchant_car_count]
                }
                merchant_df = pd.DataFrame(merchant_data)
                
                # Bar chart cho Merchant Amount
                fig_merchant = px.bar(
                    merchant_df,
                    x='Lo·∫°i xe',
                    y='T·ªïng ti·ªÅn',
                    title="Merchant Amount theo lo·∫°i xe",
                    labels={'T·ªïng ti·ªÅn': 'T·ªïng Merchant Amount (VND)', 'Lo·∫°i xe': 'Lo·∫°i xe'},
                    color='T·ªïng ti·ªÅn',
                    color_continuous_scale='plasma'
                )
                fig_merchant.update_layout(height=400)
                st.plotly_chart(fig_merchant, use_container_width=True)
                
                # Metrics
                col_merch1, col_merch2 = st.columns(2)
                with col_merch1:
                    st.metric("üõµ Bike Merchant", f"{merchant_bike_total:,.0f} VND", f"{merchant_bike_count:,} ƒë∆°n")
                with col_merch2:
                    st.metric("üöó Car Merchant", f"{merchant_car_total:,.0f} VND", f"{merchant_car_count:,} ƒë∆°n")
            
            # T·ªïng k·∫øt
            st.markdown("### üìà T·ªïng k·∫øt Amount theo lo·∫°i xe")
            
            col_sum1, col_sum2, col_sum3, col_sum4 = st.columns(4)
            
            with col_sum1:
                total_gsm = gsm_bike_total + gsm_car_total
                st.metric("üí∞ T·ªïng GSM", f"{total_gsm:,.0f} VND")
            
            with col_sum2:
                total_merchant = merchant_bike_total + merchant_car_total
                st.metric("üí∞ T·ªïng Merchant", f"{total_merchant:,.0f} VND")
            
            with col_sum3:
                total_bike = gsm_bike_total + merchant_bike_total
                st.metric("üõµ T·ªïng Bike", f"{total_bike:,.0f} VND")
            
            with col_sum4:
                total_car = gsm_car_total + merchant_car_total
                st.metric("üöó T·ªïng Car", f"{total_car:,.0f} VND")
            
            # B·∫£ng so s√°nh
            st.markdown("#### üìã B·∫£ng so s√°nh chi ti·∫øt")
            
            comparison_data = {
                'Lo·∫°i xe': ['Bike', 'Car', 'T·ªïng c·ªông'],
                'GSM Amount': [gsm_bike_total, gsm_car_total, total_gsm],
                'Merchant Amount': [merchant_bike_total, merchant_car_total, total_merchant],
                'T·ªïng Amount': [total_bike, total_car, total_gsm + total_merchant],
                'S·ªë ƒë∆°n GSM': [gsm_bike_count, gsm_car_count, gsm_bike_count + gsm_car_count],
                'S·ªë ƒë∆°n Merchant': [merchant_bike_count, merchant_car_count, merchant_bike_count + merchant_car_count]
            }
            
            comparison_df = pd.DataFrame(comparison_data)
            
            # Format s·ªë ti·ªÅn
            comparison_df['GSM Amount'] = comparison_df['GSM Amount'].apply(lambda x: f"{x:,.0f}")
            comparison_df['Merchant Amount'] = comparison_df['Merchant Amount'].apply(lambda x: f"{x:,.0f}")
            comparison_df['T·ªïng Amount'] = comparison_df['T·ªïng Amount'].apply(lambda x: f"{x:,.0f}")
            
            st.dataframe(comparison_df, use_container_width=True, hide_index=True)
            
        else:
            st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c·ªôt 'GSM Amount' ho·∫∑c 'Merchant Amount' ƒë·ªÉ ph√¢n t√≠ch")
        
        # Sample data
        st.markdown("### üëÅÔ∏è Sample Data (10 records ƒë·∫ßu)")
        st.dataframe(df.head(10).to_pandas(), use_container_width=True)
    
    def render_taixe_search(self, df):
        order_ids_input = st.text_area(
            "Nh·∫≠p Order IDs (m·ªói d√≤ng m·ªôt ID):",
            height=100,
            key="taixe_search"
        )
        
        if st.button("üîç T√¨m ki·∫øm", key="taixe_search_btn"):
            if order_ids_input and 'ORDER_ID' in df.columns:
                order_ids = [id.strip() for id in order_ids_input.split('\n') if id.strip()]
                results = df.filter(pl.col('ORDER_ID').is_in(order_ids))
                
                if not results.is_empty():
                    st.success(f"‚úÖ T√¨m th·∫•y {results.height} b·∫£n ghi")
                    st.dataframe(results.to_pandas(), use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Order ID n√†o")
    
    def render_taixe_data_viewer(self, df):
        show_rows = st.number_input("S·ªë d√≤ng hi·ªÉn th·ªã:", min_value=10, max_value=1000, value=100, key="taixe_rows")
        st.dataframe(df.head(show_rows).to_pandas(), use_container_width=True)
    
    def render_drill_down_analysis(self):
        """Hi·ªÉn th·ªã ph√¢n t√≠ch chi ti·∫øt cho status ƒë∆∞·ª£c ch·ªçn"""
        if st.session_state.get('drill_down_data') is None:
            return
            
        drill_df = st.session_state.drill_down_data
        status = st.session_state.get('drill_down_status', 'Unknown')
        count = st.session_state.get('drill_down_count', 0)
        
        st.markdown("---")
        st.markdown(f"### üîç Chi ti·∫øt: {status}")
        st.markdown(f"**üìä T·ªïng s·ªë records:** {count:,}")
        
        # Header v·ªõi buttons
        col1, col2, col3 = st.columns([2, 1, 1])
        with col1:
            st.markdown(f"#### Danh s√°ch Order IDs v√† th√¥ng tin chi ti·∫øt")
        with col2:
            if st.button("üîô Quay l·∫°i", key="back_to_overview"):
                # Clear drill-down data
                del st.session_state.drill_down_data
                del st.session_state.drill_down_status  
                del st.session_state.drill_down_count
                st.rerun()
        with col3:
            # Export button
            if not drill_df.is_empty():
                export_df = drill_df.to_pandas()
                csv_data = export_df.to_csv(index=False)
                st.download_button(
                    label="üì• Export CSV",
                    data=csv_data,
                    file_name=f"{status}_details_{st.session_state.selected_date}.csv",
                    mime="text/csv",
                    key="export_drill_down"
                )
        
        if not drill_df.is_empty():
            # Quick stats
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                unique_orders = drill_df.select('ORDER_ID').n_unique() if 'ORDER_ID' in drill_df.columns else 0
                st.metric("üÜî Unique Orders", f"{unique_orders:,}")
            
            with col2:
                unique_merchants = drill_df.select('MERCHANT').n_unique() if 'MERCHANT' in drill_df.columns else 0
                st.metric("üè™ Merchants", f"{unique_merchants:,}")
            
            with col3:
                if 'AMOUNT' in drill_df.columns:
                    total_amount = drill_df.select(pl.col('AMOUNT').sum()).item()
                    st.metric("üí∞ Total Amount", f"{total_amount:,.0f}")
                else:
                    st.metric("üí∞ Amount", "N/A")
            
            with col4:
                if 'SERVICE_TYPE' in drill_df.columns:
                    service_counts = drill_df.group_by('SERVICE_TYPE').agg(pl.count()).height
                    st.metric("üöó Service Types", f"{service_counts}")
                else:
                    st.metric("üöó Service Types", "N/A")
            
            # Display filtered data
            if not drill_df.is_empty():
                st.markdown(f"#### üìã D·ªØ li·ªáu chi ti·∫øt ({drill_df.height:,} records)")
                
                # Convert to pandas for display
                display_df = drill_df.head(100).to_pandas()
                
                # Select important columns for display
                important_cols = []
                available_cols = display_df.columns.tolist()
                
                # Priority columns
                priority_cols = ['ORDER_ID', 'MERCHANT', 'AMOUNT', 'SERVICE_TYPE', 'RECONCILE_STATUS', 
                               'INSURANCE_STATUS', 'IS_BUSINESS_ORDER', 'ORDER_TIME', 'CREATED_TIME']
                
                for col in priority_cols:
                    if col in available_cols:
                        important_cols.append(col)
                
                # Add remaining columns
                for col in available_cols:
                    if col not in important_cols:
                        important_cols.append(col)
                
                # Reorder dataframe
                display_df = display_df[important_cols]
                
                # Display with pagination-like behavior
                st.dataframe(
                    display_df,
                    use_container_width=True,
                    height=400,
                    column_config={
                        "ORDER_ID": st.column_config.TextColumn("Order ID", width="medium"),
                        "AMOUNT": st.column_config.NumberColumn("Amount", format="%.0f"),
                        "ORDER_TIME": st.column_config.DatetimeColumn("Order Time"),
                        "CREATED_TIME": st.column_config.DatetimeColumn("Created Time"),
                    }
                )
                
                # Summary info
                st.info(f"üìù Hi·ªÉn th·ªã {len(display_df):,} trong t·ªïng s·ªë {drill_df.height:,} records")
                
            else:
                st.warning("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã")
        else:
            st.warning("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã")
    
    def render_amount_analysis_by_service_type(self, df):
        """Ph√¢n t√≠ch amount theo service type"""
        if 'SERVICE_TYPE' in df.columns:
            st.markdown("### üí∞ Ph√¢n t√≠ch Ph√≠ theo Service Type")
            
            # T·∫°o tabs cho c√°c lo·∫°i amount kh√°c nhau
            amount_cols = ['AMOUNT', 'GSM_AMOUNT', 'MERCHANT_AMOUNT', 'RECONCILED_AMOUNT']
            available_amount_cols = [col for col in amount_cols if col in df.columns]
            
            if available_amount_cols:
                amount_tabs = st.tabs([f"üìä {col.replace('_', ' ').title()}" for col in available_amount_cols])
                
                for i, amount_col in enumerate(available_amount_cols):
                    with amount_tabs[i]:
                        # Ph√¢n t√≠ch theo service type
                        service_analysis = df.group_by('SERVICE_TYPE').agg([
                            pl.col(amount_col).sum().alias('total'),
                            pl.col(amount_col).mean().alias('average'),
                            pl.count().alias('count')
                        ]).sort('total', descending=True)
                        
                        col1, col2 = st.columns([1, 1])
                        
                        with col1:
                            # Bar chart cho t·ªïng amount
                            fig_total = px.bar(
                                service_analysis.to_pandas(),
                                x='SERVICE_TYPE',
                                y='total',
                                title=f"T·ªïng {amount_col.replace('_', ' ').title()} theo Service Type",
                                labels={'total': 'T·ªïng Amount (VND)', 'SERVICE_TYPE': 'Service Type'},
                                color='total',
                                color_continuous_scale='viridis'
                            )
                            fig_total.update_layout(
                                height=400,
                                xaxis_tickangle=45,
                                yaxis_tickformat=',.0f'
                            )
                            st.plotly_chart(fig_total, use_container_width=True)
                        
                        with col2:
                            # Bar chart cho average amount
                            fig_avg = px.bar(
                                service_analysis.to_pandas(),
                                x='SERVICE_TYPE',
                                y='average',
                                title=f"Trung b√¨nh {amount_col.replace('_', ' ').title()} theo Service Type",
                                labels={'average': 'Trung b√¨nh Amount (VND)', 'SERVICE_TYPE': 'Service Type'},
                                color='average',
                                color_continuous_scale='plasma'
                            )
                            fig_avg.update_layout(
                                height=400,
                                xaxis_tickangle=45,
                                yaxis_tickformat=',.0f'
                            )
                            st.plotly_chart(fig_avg, use_container_width=True)
                        
                        # B·∫£ng summary
                        st.markdown(f"#### üìã Chi ti·∫øt {amount_col.replace('_', ' ').title()}")
                        
                        summary_data = []
                        total_all = service_analysis.select(pl.col('total').sum()).item()
                        
                        for row in service_analysis.iter_rows(named=True):
                            # Handle None values for average
                            avg_value = row['average'] if row['average'] is not None else 0
                            summary_data.append({
                                'Service Type': row['SERVICE_TYPE'],
                                'T·ªïng Amount': f"{row['total']:,.0f}",
                                'S·ªë l∆∞·ª£ng': f"{row['count']:,}",
                                'Trung b√¨nh': f"{avg_value:,.0f}",
                                'T·ª∑ l·ªá t·ªïng': f"{(row['total'] / total_all * 100):.1f}%" if total_all > 0 else "0%"
                            })
                        
                        summary_df = pd.DataFrame(summary_data)
                        st.dataframe(summary_df, use_container_width=True, hide_index=True)
                        
                        # Overall summary metrics
                        col_m1, col_m2, col_m3 = st.columns(3)
                        
                        with col_m1:
                            st.metric("üí∞ T·ªïng c·ªông", f"{total_all:,.0f} VND")
                        
                        with col_m2:
                            total_count = service_analysis.select(pl.col('count').sum()).item()
                            avg_all = total_all / total_count if total_count > 0 else 0
                            st.metric("üìä Trung b√¨nh chung", f"{avg_all:,.0f} VND")
                        
                        with col_m3:
                            st.metric("üìù T·ªïng giao d·ªãch", f"{total_count:,}")
            else:
                st.info("‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y c·ªôt amount ƒë·ªÉ ph√¢n t√≠ch")
        else:
            st.info("‚ÑπÔ∏è Kh√¥ng c√≥ c·ªôt SERVICE_TYPE ƒë·ªÉ ph√¢n t√≠ch")
    
    def render_business_analysis(self, df):
        """Ph√¢n t√≠ch Business Orders"""
        if 'IS_BUSINESS_ORDER' in df.columns:
            st.markdown("### üè¢ Ph√¢n t√≠ch Business Orders")
            
            business_stats = df.group_by('IS_BUSINESS_ORDER').agg(
                pl.count().alias('count')
            ).sort('count', descending=True)
            
            col1, col2 = st.columns([1, 1])
            
            with col1:
                # Pie chart cho business orders
                # Clean up labels for better display
                clean_labels = []
                clean_values = []
                for row in business_stats.iter_rows(named=True):
                    label = row['IS_BUSINESS_ORDER']
                    value = row['count']
                    if str(label).lower() in ['true', '1', 'yes']:
                        clean_labels.append('Business Orders')
                    elif str(label).lower() in ['false', '0', 'no']:
                        clean_labels.append('Non-Business Orders')
                    else:
                        clean_labels.append(f'Unknown ({label})')
                    clean_values.append(value)
                
                fig = px.pie(
                    values=clean_values,
                    names=clean_labels,
                    title="Ph√¢n b·ªë Business vs Non-Business",
                    color_discrete_sequence=['#FF9999', '#66B2FF', '#99FF99']
                )
                fig.update_traces(textposition='inside', textinfo='percent+label')
                fig.update_layout(height=350)
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                # B·∫£ng th·ªëng k√™ chi ti·∫øt
                business_df = pd.DataFrame(
                    list(zip(clean_labels, clean_values)),
                    columns=['Lo·∫°i ƒë∆°n h√†ng', 'S·ªë l∆∞·ª£ng']
                )
                business_df['T·ª∑ l·ªá %'] = (business_df['S·ªë l∆∞·ª£ng'] / business_df['S·ªë l∆∞·ª£ng'].sum() * 100).round(2)
                
                st.markdown("**üìä Th·ªëng k√™ chi ti·∫øt:**")
                st.dataframe(business_df, use_container_width=True, hide_index=True)
                
                # Summary metrics
                total_orders = sum(clean_values)
                business_count = next((v for l, v in zip(clean_labels, clean_values) if 'Business' in l and 'Non-' not in l), 0)
                business_rate = (business_count / total_orders * 100) if total_orders > 0 else 0
                
                st.metric("üìà T·ª∑ l·ªá Business", f"{business_rate:.1f}%")
                st.metric("üìù T·ªïng ƒë∆°n h√†ng", f"{total_orders:,}")
        else:
            st.info("‚ÑπÔ∏è Kh√¥ng c√≥ c·ªôt IS_BUSINESS_ORDER ƒë·ªÉ ph√¢n t√≠ch")
    
    def render_service_type_analysis(self, df):
        """Ph√¢n t√≠ch Service Type (Ride/Express)"""
        if 'SERVICE_TYPE' in df.columns:
            st.markdown("### üöó Ph√¢n t√≠ch Service Type")
            
            service_stats = df.group_by('SERVICE_TYPE').agg(
                pl.count().alias('count')
            ).sort('count', descending=True)
            
            col1, col2 = st.columns([1, 1])
            
            with col1:
                # Bar chart cho service types
                fig = px.bar(
                    service_stats.to_pandas(),
                    x='SERVICE_TYPE',
                    y='count',
                    title="Ph√¢n b·ªë theo Service Type",
                    labels={'count': 'S·ªë l∆∞·ª£ng', 'SERVICE_TYPE': 'Service Type'},
                    color='count',
                    color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']
                )
                fig.update_layout(
                    height=350,
                    xaxis_tickangle=45
                )
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                # B·∫£ng th·ªëng k√™ chi ti·∫øt
                service_df = pd.DataFrame(
                    list(service_stats.iter_rows(named=True)),
                    columns=['Service Type', 'S·ªë l∆∞·ª£ng']
                )
                service_df['T·ª∑ l·ªá %'] = (service_df['S·ªë l∆∞·ª£ng'] / service_df['S·ªë l∆∞·ª£ng'].sum() * 100).round(2)
                
                st.markdown("**üìä Th·ªëng k√™ chi ti·∫øt:**")
                st.dataframe(service_df, use_container_width=True, hide_index=True)
                
                # Summary metrics
                total_orders = sum(service_df['S·ªë l∆∞·ª£ng'])
                # Convert to string before using .str accessor
                service_df['Service Type'] = service_df['Service Type'].astype(str)
                ride_count = service_df[service_df['Service Type'].str.contains('Ride', case=False, na=False)]['S·ªë l∆∞·ª£ng'].sum()
                express_count = service_df[service_df['Service Type'].str.contains('Express', case=False, na=False)]['S·ªë l∆∞·ª£ng'].sum()
                
                st.metric("üöó Ride Orders", f"{ride_count:,}")
                st.metric("‚ö° Express Orders", f"{express_count:,}")
        else:
            st.info("‚ÑπÔ∏è Kh√¥ng c√≥ c·ªôt SERVICE_TYPE ƒë·ªÉ ph√¢n t√≠ch")
    
    def run(self):
        print(f"DEBUG: run() called - current_tab: {st.session_state.current_tab}")
        self.render_header()
        self.render_sidebar()
        
        # Render content based on current tab
        print(f"DEBUG: About to render content for tab: {st.session_state.current_tab}")
        
        if st.session_state.current_tab == "launcher":
            print(f"DEBUG: Rendering launcher")
            self.render_launcher()
        elif st.session_state.current_tab == "reconciliation":
            print(f"DEBUG: Rendering reconciliation dashboard")
            self.render_reconciliation_dashboard()
        elif st.session_state.current_tab == "taixe":
            print(f"DEBUG: Rendering taixe dashboard")
            self.render_taixe_dashboard()
        else:
            print(f"DEBUG: Unknown tab: {st.session_state.current_tab}, defaulting to launcher")
            self.render_launcher()

if __name__ == "__main__":
    app = DashboardApp()
    app.run() 